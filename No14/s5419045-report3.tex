\documentclass[dvipdfmx]{jsarticle}
\usepackage[T1]{fontenc}
\usepackage[dvipdfmx]{hyperref}
\usepackage{lmodern}
\usepackage{latexsym}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{here}
\usepackage{float}
\usepackage{ascmac}
\usepackage{url}
\newtheorem{dfn}{定義}
\newtheorem{thm}{定理}

\title{解集合プログラミングの宣言的問題解決に関する計算機実験}
\author{文理学部情報科学科\\5419045 高林 秀}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
本稿は、今年度論理と計算2の課題研究として、具体的な問題に対してILAPSシステムを用いて解答するものである。本稿前半部では、解答に必要な計算理論の説明を行う。後半部では、実際にILAPSシステムを使用して、与えられた問題に回答していく計算機実験を行う。
\end{abstract}

\tableofcontents

\section{目的}
本稿は今年度論理と計算2の第３回目の課題研究として、ILASP システムを用いた宣言的問題解決を通じ，解集合プログラムに基づく帰納推論に関する学修内容を振り返ることを目的とする。必要な計算理論の説明を通して学習内容の復習を図るとともに、本稿後半部に記載する問題の計算機実験を通して、内容の定着を図るものとする。\par

\section{計算理論説明}
この章では、今回の計算機実験に使用した各計算理論の解説を行う。
\subsection{推論の概要}
推論とは、デジタル大辞泉には以下のように記されている。
\begin{quote}
  ある事実をもとにして、未知の事柄をおしはかり論じること。「実験の結果から推論する」\par
\end{quote}
すなわち、現在知っている事実。知識を元に新たな事実を導くことを示す。\par
推論にはいくつかその手法により種類が存在する。
\begin{itemize}
  \item 演繹推論
  \item 帰納推論
  \item 発想推論
  \item 類推推論
\end{itemize}
\paragraph{演繹推論}演繹推論は単に演繹法とも呼ばれ、後述する帰納法とは反対の推論手法となる。一般的、すなわち普遍的な事実やルールを前提（条件）とし、特定の場合、ケースに適用して結論を得る推論手法である。\par
具体例を以下に示す。既知の普遍的な事実として以下2つのルールが与えられているとする。
\begin{enumerate}
  \item パソコンは電気を使う。
  \item 電気を使うのは機械である。
\end{enumerate}
この2つのルールから、次の新たなルール、事実が導き出せる。
\begin{center}
  \item パソコンは機械である。
\end{center}
いま、前提1,2から上記の新たな事実を導いた。このように、前提となる事実・ルールから新たな事実を論ずるのが演繹推論である。\par
ただし演繹推論では、前提に偏った観点や、論理が混在した場合、その論理は成立しなくなることに注意が必要である。前提の論理が正しく確立していれば、強力な論理として成立させることが可能な推論方法である。
\paragraph{帰納推論}帰納推論は単に帰納法とも呼ばれ、既知の事実や事例から読み取れる傾向を総合し結論を論ずる推論方法である。特定のケース、条件と結論のセットからあるルールを導出する。\par
具体例を示す。既知の事実として以下の情報が与えられているとする。
\begin{enumerate}
  \item 朝のニュース番組で原油価格についての報道があった。加えて、近所のガソリンスタンドの１リッターあたりの単価が以前より高くなっていた。
  \item 友人からもガゾリン代が高くなったので車での外出は控えているという話を聞いた。
\end{enumerate}
以上2つの既知の事実から、全国的にガソリン価格が高騰している、という結論が導き出せる。このように、既知の事実から同一の傾向を抽出し結論を導く、これが帰納推論である。つまり、ケースと結論の対関係からルールを導出するということである。\par
詳細については後述する。
\paragraph{発想推論}発想推論とは、普遍的なルールと結論から、あるケース、条件を導出する推論手法である。これまでの推論では、あくまで前提から結論を導出していたのに対して、この発想推論では前提部のケース、条件を結論から推論する。詳細は後述する。
\paragraph{類推推論}デジタル大辞泉に、類推の意味が次のように書かれている。
\begin{quote}
  \begin{enumerate}
    \item 類似の点をもとにして、他を推しはかること。「過去の事例から類推する」
    \item 論理学で、二つの事物の間に本質的な類似点があることを根拠にして、一方の事物がある性質をもつ場合に他方の事物もそれと同じ性質をもつであろうと推理すること。結論は蓋然的。類比推理。類比。比論。アナロジー。
    \item ある語形または文法形式との関連から、本来の語形または文法形式とは別の新しい語形または文法形式を作ろうとする心理的な作用。この種の働きによって、多くの不規則な語形が規則化されていくことがある。
  \end{enumerate}
\end{quote}
これまでの推論手法は、基となる事実があり、そこから結論またはルールを導き出す。これに対し、類推推論では、似たような事実から結論を導き出すということを行う。すなわち、推論をする際に用いる事実や知識が他の推論手法と異なっているという点で違いがある。

\subsection{発想推論(abduction)の説明}
発想推論とは、一言で述べると仮説の形成である。$a$を前提（仮定）,$b$を結論としたとき、$b$にある規則「$aならばb$」を当てはめて$a$を推論する。帰納推論が仮定と結論の傾向から、ルールや規則を導出したり、演繹推論が、前提となる事実・ルールから新たな事実を論ずるのとは異なり、発想推論は結論と規則から「仮定$a$」を求めるという点で大きな違いがある。\par
\paragraph{形式的定義}
発想推論の形式的定義として、論理式$P$と観測事実$G$に関して$P \nvDash G$であるとき、$(P \cup \Delta \models G) \wedge (p \cup \Delta)$は矛盾しないことを満足させる、論理式の集合$\Delta$を求める、というように示すことができる。$P$に$\Delta$を保管することにより、$G$を説明、証明することができる。\par
$\Delta$を「発想的説明」と呼ぶことがある。加えて、$P \cup \Delta$を「発想的拡張」と呼ぶことがある。$\Delta$に入れることができる文の区分（クラス）を「候補仮説集合」と呼ぶ。このとき、$\Delta$の条件として以下の点を満たさなければならない。
\begin{itemize}
  \item 候補仮説集合の要素はすべて原子文であること
  \item 与えられた一貫性制約を満たすこと
  \item 説明が基本的であること
  \item 説明が極小(minmal)であること
\end{itemize}


\paragraph{発想推論の注意すべき点}
発想推論において注意すべき点としては、推論して導出した仮定$a$が真理値的に真(true)であることが保証されないという点である。これに関しては次の具体例で説明する。\par
以下のようにそれぞれ記号の意味を定めるとする。
\begin{itemize}
  \item $na$:アリバイなし
  \item $c$:犯人である
  \item ルール:$c \Rightarrow na$(犯人であるならばアリバイなし。)
\end{itemize}
このとき、発想推論を行い前提（仮定）部分の$c$を導出してみる。節集合として$\{ c, c \Rightarrow na\}$と$\{ na, c \Rightarrow na\}$があり以下のような伴意関係が導ける。
\begin{align*}
  & \{c, c \Rightarrow na\} \models na  \cdots 1 \\
  & \{ na, c \Rightarrow na\} \models c \cdots 2 \\
\end{align*}
このとき、式1に関しては、節集合のどれか一つがtrueであるとき、例えば、$c = true$すなわち犯人であることが真であるときは、必然的に犯人であるので「$na$アリバイなし」は成立する。したがって、式１に関しては成立する。しかし、式２に関して、$na = true$すなわち「アリバイがない」という条件だけでは犯人であるか否かを決定することができない、すなわち$c$が$true$か$false$であるかを決定することはできないので、式2に関しては成立できない。したがって、仮に発想推論の結論として仮定$a$を求めたとしてもその結論が真であるか否かは保証されない。よって求めた仮定が本当に正しいかどうかに関しては別で議論する必要がある。

\subsection{帰納推論の説明}
先に示したように、帰納推論は既知の事実や事例から読み取れる傾向を総合し結論を論ずる推論方法である。特定のケース、条件と結論のセットからあるルールを導出する。\par
フランシス・ベーコンによって提案された概念で、これをより人間学に近いよう噛み砕いたものは特に「ジョン・ロックの経験論」と呼ばれる。\par
帰納推論は、その手法から概念学習と称されることがある。個別事実の細部を無視し、共通して見られる部分や傾向を抽出することで一般的な概念を学習する。これは帰納学習とも呼ばれる。\par
一般的に、帰納とは人間のような知的判断力を有する生物が行動を学習する原理を定式化したものである。以下に他の推論との比較表を挙げる。（引用元：Wikipedia「帰納」\url{https://ja.wikipedia.org/wiki/%E5%B8%B0%E7%B4%8D}）
%here is table
\begin{table}[H]
\scalebox{0.7}{
\begin{tabular}{|c|l|l|l|l|}
\hline
\multicolumn{1}{|l|}{} & 演繹推論                   & 狭義的な帰納推論               & 発想推論                   & 類推推論                   \\ \hline
例 &
  \begin{tabular}[c]{@{}l@{}}前提１：aならばbである\\ 前提２：aである\\ 結論：bである\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}前提１：a1はPである\\ 前提２：a2もPである\\ 結論：（たぶん）すべてのaはPである\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}前提１：aである\\ 前提２：Hと仮定するとaが説明できる\\ 結論：（たぶん）Hである\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}前提１：aはPである\\ 前提２：bはaと似ている\\ 結論：（たぶん）bはPである\end{tabular} \\ \hline
情報量増加                  & \multicolumn{1}{c|}{×} & \multicolumn{1}{c|}{〇} & \multicolumn{1}{c|}{〇} & \multicolumn{1}{c|}{〇} \\ \hline
真理保存性                  & \multicolumn{1}{c|}{〇} & \multicolumn{1}{c|}{×} & \multicolumn{1}{c|}{×} & \multicolumn{1}{c|}{×} \\ \hline
\end{tabular}

}
\caption{推論手法の比較}
\end{table}
ここには書かれていないが、表内の補足事項として以下を挙げる。\par
演繹推論における情報量増加が起きないことに関しては、結論の内容はすべて前提の内容に含まれていることが理由である。また、真理値保存性に関しては、妥当な演繹推論は前提が正しければ必ず結論は正しいからである。\par
他の推論方式に関して、まず情報量の増加が起こることに関しては、結論が、前提に含まれていた内容を超える内容を持つのが理由である。また、真理値保存性に関しては、先に示した発想推論のように前提が正しくても、結論の正しさは保証されないのが理由である。\par
また、帰納推論の欠点として、推論の際に複数の事実や事例をすべて考慮しなければ証明したことにならないという欠点がある。
\paragraph{帰納学習の例}これまでの講義の中から帰納学習に該当する機械学習がある。それは決定木学習である。決定木は、各属性の分岐条件に対するtrue,falseによる分類で構成される木構造を用いたルール表現であり、得られたルール（木構造）から入力が何に分類されるか推論することができる。すなわち、決定木は単に機械学習の一手法というだけでなく、命題論理に置き換えれば、帰納学習を使用した学習器、学習モデルと言える。\par
また、余談だが帰納学習を用いた具体例として、Googleが開発している「alphaGo」が挙げられる。盤面における適切な手や勝利条件をもとに結論を導いている点において帰納学習が大きく関わっている。
\subsubsection{帰納論理プログラミング（Inductive logic programming）}帰納推論を使用した論理プログラミングを帰納論理プログラミングと呼ぶ。コンピュータが理解できる知識表現の範囲で帰納推論を行うための手法の一つとしてこの帰納論理プログラミングが挙げられる。帰納論理プログラミングでは、様々な分類問題を扱うことができるのに加え、背景知識を利用した事例、事実の一般化を行える。また、ある学習結果を別の学習に利用することができる転移学習も行える。加えて、帰納推論の特徴である、事例間の共通した傾向、パターンの抽出を行える。\par
帰納論理プログラミングを用いる例として、家族関係の学習や、得られたルールを利用して論理プログラムを自動的に合成したりできる。
\paragraph{問題設定}論理プログラミングにおける問題設定とは、入力と出力に関する論理的関係を示したもので、得られる解が満たすべき論理的性質を定めたものを意味する。その設定の内容により、以下のように区分されている。
\begin{itemize}
  \item 伴意からの学習（Learning from Entailment）
  \item 解釈からの学習（Learning from Interpretation）
  \item 充足可能性からの学習（Learning from Satisfiability）
  \item 解集合からの学習（Learning from Answer sets）
\end{itemize}
問題設定を行う上で必要な事項を挙げると、まず初めに与えられた問題の形式的な記述表現が求められる。すなわち、入力値としてどう表現するか設定する必要がある。次に、共通パターンの形式的記述すなわち、出力で得られる仮説をどのように表現するか設定する。次に、各事例に特定のパターンが出現するか確認し、仮説空間と設定を行う。最後に得られる仮説に関して、評価関数を使用して仮説の順位付けをする。\par
なお今回の実験で使用するのは解集合からの学習（Learning from Answer sets）であるので、ここでは問題設定の一例として伴意からの学習のみ説明する。
問題設定は下記。
\begin{itemize}
  \item 入力：正例$E^+$、負例$E^-$、関連知識$BK$ \par
  ※すべて述語論理で表現。また、$BK \nvDash E^+$ （背景知識のみでは正例を説明できない）。
  \item 出力：仮説$H$\par
  ※すべて述語論理で表現。$H$は以下の条件を満たす。
  \begin{flalign*}
      & (1).BK \cup H \models E^+ &\\
      & (2).BK \cup H \nvDash E^- &\\
  \end{flalign*}
\end{itemize}
またこのとき、仮説の評価関数として「記述長最小原理」など複数の評価関数が提案されている。
\paragraph{記述長最小原理}記述長最小原理は、正例を「仮説＋例外」の形式置き換えて、記述量の差を計算し仮説を評価する。この値が最大の仮説が良い仮説とされ、順位付けされる。
近似式は下記。
\begin{align*}
  Compression Gain(評価値) &= 説明される正例数-仮説のリテラル長-説明される負例の数 \\
  &= |概念の外延表記|-|概念の内包表記|-|例外表現|
\end{align*}

\paragraph{補足}数学的帰納法や、構造的帰納法などの手法は、名称に帰納とついているが、手法としては演繹に当たる。
\subsection{解集合からの学習}
標準論理プログラム$P$は、複数個の安定モデルないしは解集合をもつ。$P$の解集合全体の集合を$AS(P)$と表記する。
標準論理プログラム$P$の帰納推論に関する問題設定には以下のものが存在する。
\begin{itemize}
  \item Cautious Induction
  \item Brave Induction
  \item Induction of Stable Models
  \item Learning from Answer sets(解集合からの学習)
\end{itemize}
\paragraph{Cautious Induction}問題設定は下記。
\begin{itemize}
  \item 入力：背景知識$B$、仮説空間$S_M$、正例の集合$E^+$、負例の集合$E^-$
  \item 出力：仮説$H$\par
  ※$H$は以下の条件を満たす。
  \begin{flalign*}
      & (1).H \subseteq S_M \cdot Hは仮説空間&\\
      & (2).AS(B \cup H) \neq \phi \cdot Bと併せた際に解集合をもつ&\\
      & (3).\forall A \in AP(B \cup H) [ E^+ \subseteq A, E^- \cap A = \phi ] & \cdot すべての解集合は正例のみを含み負例を含まない\\
  \end{flalign*}
\end{itemize}
\paragraph{Brave Induction}問題設定は下記
\begin{itemize}
  \item 入力(Cautious Inductionと同一)：背景知識$B$、仮説空間$S_M$、正例の集合$E^+$、負例の集合$E^-$
  \item 出力：仮説$H$\par
  ※$H$は以下の条件を満たす。
  \begin{flalign*}
      & (1).H \subseteq S_M \cdot Hは仮説空間&\\
      & (3).\exists A \in AP(B \cup H) [ E^+ \subseteq A, E^- \cap A = \phi ] & \cdot 正例のみを含み負例を含まない解集合が存在する\\
  \end{flalign*}
\end{itemize}
以上の２つの問題設定における違いは、出力される仮説の条件(3)にある。Cautious Inductionでは、$A$は全称限量され解集合すべてが条件を満たさなければならない。Brave Inductionでは存在限量され、一部の解集合にて条件を満たせば良い。
\paragraph{Induction of stable models}複数の解釈からの学習を行うには、Induction of stable modelsと呼ばれる問題設定を使用する。基礎アトム（基礎原子式）を$e$とすると、部分解釈は$e^{inc}, e^{exc}$で示され、それぞれ以下を示す。
\begin{itemize}
  \item $e^{inc}$:解釈に含まれるべきアトムの集合
  \item $e^{exc}$:解釈に含まれるべきではないアトムの集合
\end{itemize}
このとき、ある解釈$I$が条件「$e^{inc} \subseteq I, e^{exc} \cap I = \phi$」を満たすとき、$I$は$e$を拡大する、と言う。
問題設定は下記。
\begin{itemize}
  \item 入力：背景知識$B$、仮説空間$S_M$、部分解釈集合$E$
  \item 出力：仮説$H$\par
  ※$H$は以下の条件を満たす。
  \begin{flalign*}
      & (1).H \subseteq S_M \cdot Hは仮説空間&\\
      & (3).\forall <e^{inc}, e^{exc}> \in E, \exists A \in AP(B \cup H)[e^{inc} \subseteq A, e^{exc} \cap A = \phi]\\
  \end{flalign*}
上記式は、事例となる各部分解釈に対し、それぞれ拡大する任意の解集合が存在することを示す。
\end{itemize}
なお、Brave Inductionとの違いとして、Brave Inductionはすべての事例を説明するのが１つの解集合であるのに対し、Induction of stable modelsは事例ごとにそれを説明する解集合は異なっている。\par
\paragraph{解集合からの学習（Learning from Answer Sets）}
最後に後述するILASPシステムの基本的な問題設定とされる解集合からの学習（Learning from Answer Sets）について述べる。問題設定は下記。

\subsection{ILASPシステムの概要}
\subsection{初期のILAPSにおける仮説導出アルゴリズム}

\section{計算機実験}
\subsection{実験準備}
  \subsubsection{実験環境}
  今回の実験は仮想マシン上でclaspのバイナリをダウンロードして行った。下記に実験時の環境を示す。
  \begin{itemize}
    \item ホストOS：Window10 Home 20H2
    \item 仮想OS：Ubuntu 20.04.2 LTS
    \item CPU：Intel(R)Core(TM)i7-9700K @ 3.6GHz
    \item GPU：Nvidia Geforce RTX2070 OC @ 8GB
    \item ホストRAM：16GB
    \item 仮想RAM：4GB
    \item clingo version : 5.4.0
  \end{itemize}

\section{巻末資料}
  本稿で使用した画像、プログラムコード等はすべて以下のリンク先に掲載している。必要に応じてご覧頂きたい。
  \begin{itemize}
    \item GoogleDrive:\url{https://drive.google.com/drive/folders/1YZg84--BFR0XRyXArL1TTY5m5xGxITxG?usp=sharing}
    \item GitHub:\url{https://github.com/tsyu12345/logical_and_calculating_LectureCode/tree/master/No14}
  \end{itemize}
\end{document}
